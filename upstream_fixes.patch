From 5a0c4a7fe94263f9046b915fcba23df1e6c9083e Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 20 Aug 2017 18:22:07 -0700
Subject: [PATCH 02/10] Revert freeing closures in idle handler

This turned out to cause a lot of problems; it has been responsible for
almost all of the crashes in gnome-shell since 1.48. We revert back to
the original code modulo a few improvements that have been made along the
way.

This state at least does not crash in the test suite, although it is
definitely not correct since it breaks SpiderMonkey's garbage collector
pre barrier verification mode (the reason the change was made in the
first place.) That still must be fixed using a different approach.

This partially reverts commits [41b78ae], [db3e387], [bace908],
[9eb4a2b], [2593d3d], and [334ba96].

https://bugzilla.gnome.org/show_bug.cgi?id=786668

https://bugzilla.gnome.org/show_bug.cgi?id=785657
---
 gi/closure.cpp | 39 +++++++----------------------------
 gi/object.cpp  | 64 ++++------------------------------------------------------
 2 files changed, 11 insertions(+), 92 deletions(-)

diff --git a/gi/closure.cpp b/gi/closure.cpp
index 71dc72ce..b00172aa 100644
--- a/gi/closure.cpp
+++ b/gi/closure.cpp
@@ -35,7 +35,6 @@
 struct Closure {
     JSContext *context;
     GjsMaybeOwned<JSObject *> obj;
-    unsigned idle_clear_id;
 };
 
 struct GjsClosure {
@@ -117,25 +116,6 @@ global_context_finalized(JS::HandleObject obj,
     }
 }
 
-/* Closures have to drop their references to their JS functions in an idle
- * handler, because otherwise the closure might stop tracing the function object
- * in the middle of garbage collection. That is not allowed with incremental GC.
- */
-static gboolean
-closure_clear_idle(void *data)
-{
-    auto closure = static_cast<GjsClosure *>(data);
-    gjs_debug_closure("Clearing closure %p which calls object %p",
-                      &closure->priv, closure->priv.obj.get());
-
-    closure->priv.obj.reset();
-    closure->priv.context = nullptr;
-    closure->priv.idle_clear_id = 0;
-
-    g_closure_unref(static_cast<GClosure *>(data));
-    return G_SOURCE_REMOVE;
-}
-
 /* Invalidation is like "dispose" - it is guaranteed to happen at
  * finalize, but may happen before finalize. Normally, g_closure_invalidate()
  * is called when the "target" of the closure becomes invalid, so that the
@@ -176,18 +156,20 @@ closure_invalidated(gpointer data,
                       "removing our destroy notifier on global object)",
                       closure);
 
-    c->idle_clear_id = g_idle_add(closure_clear_idle, closure);
-    g_closure_ref(closure);
+    c->obj.reset();
+    c->context = nullptr;
 }
 
 static void
 closure_set_invalid(gpointer  data,
                     GClosure *closure)
 {
+    Closure *self = &((GjsClosure*) closure)->priv;
+
+    self->obj.reset();
+    self->context = nullptr;
+
     GJS_DEC_COUNTER(closure);
-    Closure *c = &(reinterpret_cast<GjsClosure *>(closure))->priv;
-    c->idle_clear_id = g_idle_add(closure_clear_idle, closure);
-    g_closure_ref(closure);
 }
 
 static void
@@ -196,13 +178,6 @@ closure_finalize(gpointer  data,
 {
     Closure *self = &((GjsClosure*) closure)->priv;
 
-    if (self->idle_clear_id > 0) {
-        /* Remove any pending closure_clear_idle(), we are doing it
-         * immediately here. */
-        g_source_remove(self->idle_clear_id);
-        closure_clear_idle(closure);
-    }
-
     self->~Closure();
 }
 
diff --git a/gi/object.cpp b/gi/object.cpp
index df00b9b7..51ef8343 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -24,7 +24,6 @@
 #include <config.h>
 
 #include <deque>
-#include <map>
 #include <memory>
 #include <set>
 #include <stack>
@@ -66,7 +65,6 @@ struct ObjectInstance {
 
     /* a list of all signal connections, used when tracing */
     std::set<ConnectData *> signals;
-    std::map<ConnectData *, unsigned> pending_invalidations;
 
     /* the GObjectClass wrapped by this JS Object (only used for
        prototypes) */
@@ -1408,61 +1406,14 @@ object_instance_trace(JSTracer *tracer,
         vfunc->js_function.trace(tracer, "ObjectInstance::vfunc");
 }
 
-/* Removing the signal connection data from the list means that the object stops
- * tracing the JS function objects belonging to the closures. Incremental GC
- * does not allow that in the middle of a garbage collection. Therefore, we must
- * do it in an idle handler.
- */
-static gboolean
-signal_connection_invalidate_idle(void *user_data)
-{
-    auto cd = static_cast<ConnectData *>(user_data);
-    cd->obj->pending_invalidations.erase(cd);
-    cd->obj->signals.erase(cd);
-    g_slice_free(ConnectData, cd);
-    return G_SOURCE_REMOVE;
-}
-
 static void
 signal_connection_invalidated(void     *data,
                               GClosure *closure)
 {
     auto cd = static_cast<ConnectData *>(data);
-    std::map<ConnectData *, unsigned>& pending = cd->obj->pending_invalidations;
-    g_assert(pending.count(cd) == 0);
-    pending[cd] = g_idle_add(signal_connection_invalidate_idle, cd);
-}
-
-/* This is basically the same as invalidate_all_signals(), but does not defer
- * the invalidation to an idle handler. */
-static void
-invalidate_all_signals_now(ObjectInstance *priv)
-{
-    for (auto& iter : priv->pending_invalidations) {
-        ConnectData *cd = iter.first;
-        g_source_remove(iter.second);
-        g_slice_free(ConnectData, cd);
-        /* Erase element if not already erased */
-        priv->signals.erase(cd);
-    }
-    priv->pending_invalidations.clear();
 
-    /* Can't loop directly through the items, since invalidating an item's
-     * closure might have the effect of removing the item from the set in the
-     * invalidate notifier. */
-    while (!priv->signals.empty()) {
-        ConnectData *cd = *priv->signals.begin();
-
-        /* We have to remove the invalidate notifier, which would
-         * otherwise schedule a new pending invalidation. */
-        g_closure_remove_invalidate_notifier(cd->closure, cd,
-                                             signal_connection_invalidated);
-        g_closure_invalidate(cd->closure);
-
-        g_slice_free(ConnectData, cd);
-        /* Erase element if not already erased */
-        priv->signals.erase(cd);
-    }
+    cd->obj->signals.erase(cd);
+    g_slice_free(ConnectData, cd);
 }
 
 static void
@@ -1484,16 +1435,9 @@ object_instance_finalize(JSFreeOp  *fop,
                                     priv->info ? g_base_info_get_namespace((GIBaseInfo*) priv->info) : "_gjs_private",
                                     priv->info ? g_base_info_get_name((GIBaseInfo*) priv->info) : g_type_name(priv->gtype)));
 
-    /* We must invalidate all signal connections now, instead of in an idle
-     * handler, because the object will not exist anymore when we get around to
-     * the idle function. We originally needed to defer these invalidations to
-     * an idle function since the object needs to continue tracing its signal
-     * connections while GC is going on. However, once the object is finalized,
-     * it will not be tracing them any longer anyway, so it's safe to do them
-     * now.
-     * This applies only to instances, not prototypes, but it's possible that
+    /* This applies only to instances, not prototypes, but it's possible that
      * an instance's GObject is already freed at this point. */
-    invalidate_all_signals_now(priv);
+    invalidate_all_signals(priv);
 
     /* Object is instance, not prototype, AND GObject is not already freed */
     if (priv->gobj) {

From 6930b8d18b6db3a1e309d9411b796be9e4561c7b Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 22 Aug 2017 22:58:56 -0700
Subject: [PATCH 03/10] closure: Prevent collection of invalidated closure

It's not possible to stop tracing an object in the middle of GC. However,
by using JS::ExposeObjectToActiveJS(), it is possible to mark an object
as reachable for the duration of one GC. This is exactly what we need for
closures, to keep the closure's callable object from disappearing while
GC is going on.

https://bugzilla.gnome.org/show_bug.cgi?id=786668

https://bugzilla.gnome.org/show_bug.cgi?id=785657
---
 gi/closure.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/gi/closure.cpp b/gi/closure.cpp
index b00172aa..4dcef120 100644
--- a/gi/closure.cpp
+++ b/gi/closure.cpp
@@ -166,6 +166,7 @@ closure_set_invalid(gpointer  data,
 {
     Closure *self = &((GjsClosure*) closure)->priv;
 
+    JS::ExposeObjectToActiveJS(self->obj);
     self->obj.reset();
     self->context = nullptr;
 

From c7ca596e5b01f57a6b7ee53eb7aa06237376bfdd Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Tue, 22 Aug 2017 09:51:52 -0700
Subject: [PATCH 04/10] arg: Fix memory leaks

Caught with Valgrind.

While touching this code, reindents it and fixes code style.

https://bugzilla.gnome.org/show_bug.cgi?id=786668
---
 gi/arg.cpp | 45 +++++++++++++++++++++------------------------
 1 file changed, 21 insertions(+), 24 deletions(-)

diff --git a/gi/arg.cpp b/gi/arg.cpp
index 96603646..97625ada 100644
--- a/gi/arg.cpp
+++ b/gi/arg.cpp
@@ -1884,9 +1884,6 @@ gjs_value_to_g_argument(JSContext      *context,
         gpointer data;
         gsize length;
         GIArrayType array_type = g_type_info_get_array_type(type_info);
-        GITypeInfo *param_info;
-
-        param_info = g_type_info_get_param_type(type_info, 0);
 
         /* First, let's handle the case where we're passed an instance
          * of our own byteArray class.
@@ -1915,6 +1912,7 @@ gjs_value_to_g_argument(JSContext      *context,
             break;
         }
 
+        GITypeInfo *param_info = g_type_info_get_param_type(type_info, 0);
         if (array_type == GI_ARRAY_TYPE_C) {
             arg->v_pointer = data;
         } else if (array_type == GI_ARRAY_TYPE_ARRAY) {
@@ -2268,33 +2266,32 @@ gjs_array_from_carray_internal (JSContext             *context,
           ITERATE(double);
           break;
         case GI_TYPE_TAG_INTERFACE: {
-          GIBaseInfo *interface_info;
-          GIInfoType info_type;
-
-          interface_info = g_type_info_get_interface (param_info);
-          info_type = g_base_info_get_type (interface_info);
+            GIBaseInfo *interface_info = g_type_info_get_interface (param_info);
+            GIInfoType info_type = g_base_info_get_type (interface_info);
 
-          if ((info_type == GI_INFO_TYPE_STRUCT ||
-               info_type == GI_INFO_TYPE_UNION) &&
-              !g_type_info_is_pointer (param_info)) {
-              gsize struct_size;
+            if ((info_type == GI_INFO_TYPE_STRUCT ||
+                 info_type == GI_INFO_TYPE_UNION) &&
+                !g_type_info_is_pointer(param_info)) {
+                size_t struct_size;
 
-              if (info_type == GI_INFO_TYPE_UNION)
-                  struct_size = g_union_info_get_size ((GIUnionInfo*)interface_info);
-              else
-                  struct_size = g_struct_info_get_size ((GIStructInfo*)interface_info);
+                if (info_type == GI_INFO_TYPE_UNION)
+                    struct_size = g_union_info_get_size(interface_info);
+                else
+                    struct_size = g_struct_info_get_size(interface_info);
 
-              for (i = 0; i < length; i++) {
-                  arg.v_pointer = ((char*)array) + (struct_size * i);
+                for (i = 0; i < length; i++) {
+                    arg.v_pointer = static_cast<char *>(array) + (struct_size * i);
 
-                  if (!gjs_value_from_g_argument(context, elems[i], param_info,
-                                                 &arg, true))
-                      return false;
-              }
+                    if (!gjs_value_from_g_argument(context, elems[i], param_info,
+                                                   &arg, true))
+                        return false;
+                }
 
-              break;
-          }
+                g_base_info_unref(interface_info);
+                break;
+            }
 
+            g_base_info_unref(interface_info);
         }
         /* fallthrough */
         case GI_TYPE_TAG_GTYPE:

From d393f97a1b354c71c15fc01680e42cf53718effa Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 29 Aug 2017 23:19:02 -0700
Subject: [PATCH 05/10] arg: Avoid assigning out-of-range values

Assigning out-of-range values to variables of these types is undefined
behaviour, and was caught by UBSan on Clang.

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 gi/arg.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/gi/arg.cpp b/gi/arg.cpp
index 97625ada..e083850e 100644
--- a/gi/arg.cpp
+++ b/gi/arg.cpp
@@ -1387,7 +1387,7 @@ gjs_value_to_g_argument(JSContext      *context,
             wrong = true;
         if (i > G_MAXUINT32 || i < 0)
             out_of_range = true;
-        arg->v_uint32 = (guint32)i;
+        arg->v_uint32 = CLAMP(i, 0, G_MAXUINT32);
         break;
     }
 
@@ -1408,7 +1408,7 @@ gjs_value_to_g_argument(JSContext      *context,
         if (v < 0)
             out_of_range = true;
         /* XXX we fail with values close to G_MAXUINT64 */
-        arg->v_uint64 = v;
+        arg->v_uint64 = MAX(v, 0);
     }
         break;
 

From 848f8d9cb27972c2d5aebeebf39658e8544938de Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Wed, 30 Aug 2017 13:36:51 -0700
Subject: [PATCH 06/10] arg: Avoid taking abs() of -2^63

It's undefined behaviour to call abs() on (int64_t)(-2^63) because 2^63
can't be stored in an int64_t. Add a special case for this value.

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 gi/arg.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/gi/arg.cpp b/gi/arg.cpp
index e083850e..1c600070 100644
--- a/gi/arg.cpp
+++ b/gi/arg.cpp
@@ -2614,7 +2614,8 @@ gjs_value_from_g_argument (JSContext             *context,
         break;
 
     case GI_TYPE_TAG_INT64:
-        if (std::abs(arg->v_int64) > MAX_SAFE_INT64)
+        if (arg->v_int64 == G_MININT64 ||
+            std::abs(arg->v_int64) > MAX_SAFE_INT64)
             g_warning("Value %" G_GINT64_FORMAT " cannot be safely stored in "
                       "a JS Number and may be rounded", arg->v_int64);
         value_p.setNumber(static_cast<double>(arg->v_int64));

From 26420dac2023c48f1f6cd028ae4f21e350440362 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Thu, 31 Aug 2017 15:08:46 -0700
Subject: [PATCH 07/10] main: Use g_option_context_parse_strv()

Using g_option_context_parse() on anything but the main function's argc
and argv will leak memory. Instead, use g_option_context_parse_strv()
which is intended for use with GStrv-style allocated arrays.

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 cjs/console.cpp | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/cjs/console.cpp b/cjs/console.cpp
index ee73c7af..d3cfcac1 100644
--- a/cjs/console.cpp
+++ b/cjs/console.cpp
@@ -99,7 +99,7 @@ check_script_args_for_stray_gjs_args(int           argc,
         { NULL }
     };
     char **argv_copy = g_new(char *, argc + 2);
-    int ix, argc_copy = argc + 1;
+    int ix;
 
     argv_copy[0] = g_strdup("dummy"); /* Fake argv[0] for GOptionContext */
     for (ix = 0; ix < argc; ix++)
@@ -110,9 +110,10 @@ check_script_args_for_stray_gjs_args(int           argc,
     g_option_context_set_ignore_unknown_options(script_options, true);
     g_option_context_set_help_enabled(script_options, false);
     g_option_context_add_main_entries(script_options, script_check_entries, NULL);
-    if (!g_option_context_parse(script_options, &argc_copy, &argv_copy, &error)) {
+    if (!g_option_context_parse_strv(script_options, &argv_copy, &error)) {
         g_warning("Scanning script arguments failed: %s", error->message);
         g_error_free(error);
+        g_strfreev(argv_copy);
         return;
     }
 
@@ -158,7 +159,7 @@ main(int argc, char **argv)
     const char *filename;
     const char *program_name;
     gsize len;
-    int code, argc_copy = argc, gjs_argc = argc, script_argc, ix;
+    int code, gjs_argc = argc, script_argc, ix;
     char **argv_copy = g_strdupv(argv), **argv_copy_addr = argv_copy;
     char **gjs_argv, **gjs_argv_addr;
     char * const *script_argv;
@@ -173,10 +174,11 @@ main(int argc, char **argv)
     g_option_context_set_help_enabled(context, false);
 
     g_option_context_add_main_entries(context, entries, NULL);
-    if (!g_option_context_parse(context, &argc_copy, &argv_copy, &error))
+    if (!g_option_context_parse_strv(context, &argv_copy, &error))
         g_error("option parsing failed: %s", error->message);
 
     /* Split options so we pass unknown ones through to the JS script */
+    int argc_copy = g_strv_length(argv_copy);
     for (ix = 1; ix < argc; ix++) {
         /* Check if a file was given and split after it */
         if (argc_copy >= 2 && strcmp(argv[ix], argv_copy[1]) == 0) {
@@ -205,7 +207,7 @@ main(int argc, char **argv)
     print_version = false;
     g_option_context_set_ignore_unknown_options(context, false);
     g_option_context_set_help_enabled(context, true);
-    if (!g_option_context_parse(context, &gjs_argc, &gjs_argv, &error))
+    if (!g_option_context_parse_strv(context, &gjs_argv, &error))
         g_error("option parsing failed: %s", error->message);
 
     g_option_context_free (context);
@@ -215,6 +217,7 @@ main(int argc, char **argv)
         exit(0);
     }
 
+    gjs_argc = g_strv_length(gjs_argv);
     if (command != NULL) {
         script = command;
         len = strlen(script);

From 47f9e8df4c80ea3c04c32e2f3fda132b4771eed2 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Thu, 31 Aug 2017 15:46:47 -0700
Subject: [PATCH 08/10] cairo: Free popped pattern

This pattern was leaked; according to the documentation the caller owns
the return value of cairo_pop_group().

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 modules/cairo-context.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/modules/cairo-context.cpp b/modules/cairo-context.cpp
index a6e467ca..cacb63ca 100644
--- a/modules/cairo-context.cpp
+++ b/modules/cairo-context.cpp
@@ -717,8 +717,8 @@ popGroup_func(JSContext *context,
     if (!gjs_cairo_check_status(context, cairo_status(cr), "context"))
         return false;
 
-    /* pattern belongs to the context, so keep the reference */
     pattern_wrapper = gjs_cairo_pattern_from_pattern(context, pattern);
+    cairo_pattern_destroy(pattern);
     if (!pattern_wrapper) {
         gjs_throw(context, "failed to create pattern");
         return false;

From f97332e1876adde3afaf93681c87842ca0576a2c Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 29 Aug 2017 23:20:41 -0700
Subject: [PATCH 09/10] object: Avoid taking address of empty vector

Given a std::vector<T> vec, &vec[0] is undefined behaviour when the
vector is empty. C++11 provides a vec.data() method which does the same
thing safely.

This is an opportunity for a small refactor; the free function didn't
actually free the vector, so it should be renamed "clear", and it can
just take in the vector instead of a pointer to the data. We can also
keep all the memory management of the vector in the same place, in
object_instance_init().

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 gi/object.cpp | 44 ++++++++++++++++++--------------------------
 1 file changed, 18 insertions(+), 26 deletions(-)

diff --git a/gi/object.cpp b/gi/object.cpp
index 51ef8343..46faf028 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -818,19 +818,10 @@ object_instance_resolve(JSContext       *context,
     return true;
 }
 
-static void
-free_g_params(GParameter *params,
-              int         n_params)
-{
-    int i;
-
-    for (i = 0; i < n_params; ++i) {
-        g_value_unset(&params[i].value);
-    }
-}
-
 /* Set properties from args to constructor (argv[0] is supposed to be
  * a hash)
+ * The GParameter elements in the passed-in vector must be unset by the caller,
+ * regardless of the return value of this function.
  */
 static bool
 object_instance_props_to_g_parameters(JSContext                  *context,
@@ -846,7 +837,6 @@ object_instance_props_to_g_parameters(JSContext                  *context,
 
     if (!args[0].isObject()) {
         gjs_throw(context, "argument should be a hash with props to set");
-        free_g_params(&gparams[0], gparams.size());
         return false;
     }
 
@@ -856,7 +846,7 @@ object_instance_props_to_g_parameters(JSContext                  *context,
     JS::RootedValue value(context);
     if (!ids) {
         gjs_throw(context, "Failed to create property iterator for object props hash");
-        goto free_array_and_fail;
+        return false;
     }
 
     for (ix = 0, length = ids.length(); ix < length; ix++) {
@@ -867,12 +857,10 @@ object_instance_props_to_g_parameters(JSContext                  *context,
          * doesn't know that */
         prop_id = ids[ix];
 
-        if (!gjs_object_require_property(context, props, "property list", prop_id, &value)) {
-            goto free_array_and_fail;
-        }
-
-        if (!gjs_get_string_id(context, prop_id, &name))
-            goto free_array_and_fail;
+        if (!gjs_object_require_property(context, props, "property list",
+                                         prop_id, &value) ||
+            !gjs_get_string_id(context, prop_id, &name))
+            return false;
 
         switch (init_g_param_from_property(context, name,
                                            value,
@@ -885,7 +873,7 @@ object_instance_props_to_g_parameters(JSContext                  *context,
             /* fallthrough */
         case SOME_ERROR_OCCURRED:
             g_free(name);
-            goto free_array_and_fail;
+            return false;
         case VALUE_WAS_SET:
         default:
             break;
@@ -897,10 +885,6 @@ object_instance_props_to_g_parameters(JSContext                  *context,
     }
 
     return true;
-
- free_array_and_fail:
-    free_g_params(&gparams[0], gparams.size());
-    return false;
 }
 
 #define DEBUG_DISPOSE 0
@@ -1267,6 +1251,13 @@ disassociate_js_gobject(GObject *gobj)
     priv->js_object_finalized = true;
 }
 
+static void
+clear_g_params(std::vector<GParameter>& params)
+{
+    for (GParameter param : params)
+        g_value_unset(&param.value);
+}
+
 static bool
 object_instance_init (JSContext                  *context,
                       JS::MutableHandleObject     object,
@@ -1290,6 +1281,7 @@ object_instance_init (JSContext                  *context,
 
     if (!object_instance_props_to_g_parameters(context, object, args,
                                                gtype, params)) {
+        clear_g_params(params);
         return false;
     }
 
@@ -1302,10 +1294,10 @@ object_instance_init (JSContext                  *context,
     }
 
 G_GNUC_BEGIN_IGNORE_DEPRECATIONS
-    gobj = (GObject*) g_object_newv(gtype, params.size(), &params[0]);
+    gobj = (GObject*) g_object_newv(gtype, params.size(), params.data());
 G_GNUC_END_IGNORE_DEPRECATIONS
 
-    free_g_params(&params[0], params.size());
+    clear_g_params(params);
 
     ObjectInstance *other_priv = get_object_qdata(gobj);
     if (other_priv && other_priv->keep_alive != object) {

From fc515f86cf689bc1626572437ff9c3b81ed727d7 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Wed, 30 Aug 2017 13:41:34 -0700
Subject: [PATCH 10/10] context: Avoid null pointer dereference

gjs_context_eval_file() was returning false but not setting the error
parameter if the file did not exist.

That check makes no sense anyway, since it is also done by
g_file_load_contents(). Therefore we remove it and take the opportunity
to refactor the function to use autoptrs.

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 cjs/context.cpp | 32 +++++++++-----------------------
 1 file changed, 9 insertions(+), 23 deletions(-)

diff --git a/cjs/context.cpp b/cjs/context.cpp
index 0c563d1d..bd372612 100644
--- a/cjs/context.cpp
+++ b/cjs/context.cpp
@@ -808,31 +808,17 @@ gjs_context_eval_file(GjsContext    *js_context,
                       int           *exit_status_p,
                       GError       **error)
 {
-    char     *script = NULL;
-    gsize    script_len;
-    bool ret = true;
+    char *script;
+    size_t script_len;
+    GjsAutoUnref<GFile> file = g_file_new_for_commandline_arg(filename);
 
-    GFile *file = g_file_new_for_commandline_arg(filename);
-
-    if (!g_file_query_exists(file, NULL)) {
-        ret = false;
-        goto out;
-    }
-
-    if (!g_file_load_contents(file, NULL, &script, &script_len, NULL, error)) {
-        ret = false;
-        goto out;
-    }
-
-    if (!gjs_context_eval(js_context, script, script_len, filename, exit_status_p, error)) {
-        ret = false;
-        goto out;
-    }
+    if (!g_file_load_contents(file, nullptr, &script, &script_len, nullptr,
+                              error))
+        return false;
+    GjsAutoChar script_ref = script;
 
-out:
-    g_free(script);
-    g_object_unref(file);
-    return ret;
+    return gjs_context_eval(js_context, script, script_len, filename,
+                            exit_status_p, error);
 }
 
 bool
